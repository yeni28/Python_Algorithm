def bfs(g, v, n) : #g : 그래프 (인접리스트), v 시작지점, n 정점의 개수
    #중복 탐색 방지를 위한 방문 배열
    visited = [0] * (n+1) #인덱스가 몇부터 시작인지를 잘 살펴봐야한다.
    # 정점 번호가 1부터 시작하면 n + 1
    # 정점 번호가 0부터 시작하면 n

    queue = [] #큐로 사용할 배열선언
    queue.append(v) #탐색을 시작할 초기 위치를 큐에 추가
    visited[v] = 1 #초기 위치는 방문했다고 체크

    # 반복을 계속 하는데
    # 초기에 탐색 시작 위치를 넣어주고 반복을 진행하기 때문에,
    # 탐색 위치가 남아있다면 큐가 비어있을 일이 없다.
    # 큐가 만약 비어있다면 탐색이 끝난 것이다.
    while queue:
        t = queue.pop(0) #큐에서 맨 앞의 원소 가져오기
        print(f'{t}', end =' ')
        # 현재 위치인 t에서 갈 수 있는 정점들이 있는지 검사
        for i in g[t] : #인접 리스트인 g(그래프)에서 t번 정점과 연결된 정점을 모두 탐색
            if not visited[i]: #다음 정점인 i를 방문한 적이 없다면 탐색대상, 탐색대상은 q에 추가를 해주면 된다. 큐에 추가한 이후 탐색했다는 표시를 위해 방문배열에 체크하면된다.
                queue.append(i)
                visited[i] = 1
# 인접리스트
graph = [[], # 1번부터 연결되어있으니 0번 인덱스에는 빈 배열을 넣으면 된다.
           [2, 3],
           [1, 4, 5],
           [1, 7],
           [2, 6],
           [2, 6],
           [4, 5, 7],
           [3, 6]]

bfs(graph, 1, 7) # bfs 탐색 시작
